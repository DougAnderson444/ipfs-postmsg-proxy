{"version":3,"sources":["../../src/client/pubsub.js"],"names":["opts","subs","api","publish","callbackify","variadic","subscribe","topic","handler","options","cb","sub","stub","args","fnName","rpc","exposedFn","data","seqno","process","nextTick","Promise","resolve","push","catch","err","close","splice","indexOf","then","res","unsubscribe","find","s","peers","ls","setMaxListeners"],"mappings":"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","file":"pubsub.js","sourcesContent":["import { caller, expose } from 'postmsg-rpc'\r\nimport callbackify from 'callbackify'\r\nimport shortid from 'shortid'\r\nimport { pre } from 'prepost'\r\nimport { functionToJson } from '../serialization/function'\r\nimport { isBufferJson, bufferFromJson, preBufferToJson } from '../serialization/buffer'\r\n\r\nexport default function (opts) {\r\n  const subs = [\r\n  /*\r\n    {\r\n      topic,      // name of the topic subscribed to\r\n      handler,    // the handler provided by the subscriber - rpc.exposedFn calls this function\r\n      rpc: {      // details of the exposed RPC function created to receive updates\r\n        fnName,   // the RPC function name\r\n        exposedFn // the exposed RPC function created by postmsg-rpc\r\n      }\r\n    }\r\n  */\r\n  ]\r\n\r\n  const api = {\r\n    publish: callbackify.variadic(\r\n      pre(\r\n        preBufferToJson(1),\r\n        caller('ipfs.pubsub.publish', opts)\r\n      )\r\n    ),\r\n    subscribe: function (topic, handler, options, cb) {\r\n      let sub\r\n\r\n      if (typeof options === 'function') {\r\n        cb = options\r\n        options = {}\r\n      }\r\n\r\n      const stub = pre(\r\n        (...args) => {\r\n          const fnName = `ipfs.pubsub.subscribe.handler.${shortid()}`\r\n\r\n          sub = {\r\n            topic,\r\n            handler,\r\n            rpc: {\r\n              fnName,\r\n              exposedFn: expose(fnName, pre(\r\n                (...args) => {\r\n                  if (args[0]) {\r\n                    if (isBufferJson(args[0].data)) {\r\n                      args[0].data = bufferFromJson(args[0].data)\r\n                    }\r\n\r\n                    if (isBufferJson(args[0].seqno)) {\r\n                      args[0].seqno = bufferFromJson(args[0].seqno)\r\n                    }\r\n                  }\r\n\r\n                  return args\r\n                },\r\n                (...args) => {\r\n                  process.nextTick(() => handler(...args))\r\n                  return Promise.resolve()\r\n                }\r\n              ), opts)\r\n            }\r\n          }\r\n\r\n          subs.push(sub)\r\n\r\n          args[1] = functionToJson(fnName)\r\n\r\n          return args\r\n        },\r\n        // If error, then remove subscription handler\r\n        (...args) => {\r\n          return caller('ipfs.pubsub.subscribe', opts)(...args)\r\n            .catch((err) => {\r\n              sub.rpc.exposedFn.close()\r\n              subs.splice(subs.indexOf(sub), 1)\r\n              throw err\r\n            })\r\n        }\r\n      )\r\n\r\n      if (cb) {\r\n        stub(topic, handler, options)\r\n          .then((res) => process.nextTick(() => cb(null, res)))\r\n          .catch((err) => process.nextTick(() => cb(err)))\r\n      } else {\r\n        return stub(topic, handler, options)\r\n      }\r\n    },\r\n    unsubscribe: callbackify.variadic(\r\n      pre(\r\n        (...args) => {\r\n          const topic = args[0]\r\n          const sub = subs.find((s) => s.topic === topic && s.handler === args[1])\r\n\r\n          if (sub) {\r\n            args[1] = functionToJson(sub.rpc.fnName)\r\n            sub.rpc.exposedFn.close()\r\n            subs.splice(subs.indexOf(sub), 1)\r\n          }\r\n\r\n          return args\r\n        },\r\n        caller('ipfs.pubsub.unsubscribe', opts)\r\n      )\r\n    ),\r\n    peers: callbackify.variadic(caller('ipfs.pubsub.peers', opts)),\r\n    ls: callbackify.variadic(caller('ipfs.pubsub.ls', opts)),\r\n    // interface-ipfs-core tests use this function\r\n    // noop since we're not an EventEmitter\r\n    setMaxListeners: () => api\r\n  }\r\n\r\n  return api\r\n}\r\n"]}