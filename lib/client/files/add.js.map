{"version":3,"sources":["../../../src/client/files/add.js"],"names":["opts","api","add","callbackify","variadic","args","fileToJsonOpts","pms","progress","onProgressIncrement","createOnProgressIncrement","Array","isArray","map","file","fileToJson","length","concat","addReadableStream","content","Transform","objectMode","transform","enc","cb","push","flush","apply","err","res","forEach","addPullStream","deferred","defer","source","abortable","readFnName","through","read","PMS","sink","then","resolve","name","catch","abort","pull","onProgress","bytes","incrementBytes","isStream","readable","pullStreamToJson","toPull","Object","assign","post","data"],"mappings":"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","file":"add.js","sourcesContent":["import { caller } from 'postmsg-rpc'\r\nimport callbackify from 'callbackify'\r\nimport { Transform } from 'stream'\r\nimport pull from 'pull-stream'\r\nimport PMS from 'pull-postmsg-stream'\r\nimport toPull from 'stream-to-pull-stream'\r\nimport isStream from 'is-stream'\r\nimport { isSource } from 'is-pull-stream'\r\nimport shortid from 'shortid'\r\nimport { pre } from 'prepost'\r\nimport defer from 'pull-defer'\r\nimport Abortable from 'pull-abortable'\r\nimport { isBuffer, bufferToJson } from '../../serialization/buffer'\r\nimport { functionToJson } from '../../serialization/function'\r\n\r\nexport default function (opts) {\r\n  const api = {\r\n    add: (() => {\r\n      const add = callbackify.variadic(\r\n        pre(\r\n          (...args) => {\r\n            const fileToJsonOpts = { pms: opts }\r\n\r\n            // FIXME: implement progress properly\r\n            if (args[1] && args[1].progress) {\r\n              fileToJsonOpts.onProgressIncrement = createOnProgressIncrement(args[1].progress)\r\n              delete args[1].progress\r\n            }\r\n\r\n            args[0] = Array.isArray(args[0])\r\n              ? args[0].map((file) => fileToJson(file, fileToJsonOpts))\r\n              : fileToJson(args[0], fileToJsonOpts)\r\n\r\n            return args\r\n          },\r\n          caller('ipfs.add', opts)\r\n        )\r\n      )\r\n\r\n      return (...args) => {\r\n        // Pull streams are just functions and so callbackify.variadic thinks\r\n        // the stream is a callback function! Instead explicitly pass null for\r\n        // the options arg.\r\n        if (args.length === 1 && isSource(args[0])) {\r\n          args = args.concat(null)\r\n        }\r\n\r\n        return add(...args)\r\n      }\r\n    })(),\r\n    // FIXME: implement add readable stream properly\r\n    addReadableStream (...args) {\r\n      const content = []\r\n      return new Transform({\r\n        objectMode: true,\r\n        transform (file, enc, cb) {\r\n          content.push(file)\r\n          cb()\r\n        },\r\n        flush (cb) {\r\n          api.add.apply(api, [content].concat(args, (err, res) => {\r\n            if (err) return cb(err)\r\n            res.forEach((file) => this.push(file))\r\n            cb()\r\n          }))\r\n        }\r\n      })\r\n    },\r\n    addPullStream: (() => {\r\n      const addPullStream = caller('ipfs.files.addPullStream', opts)\r\n\r\n      return (...args) => {\r\n        const deferred = defer.source()\r\n        const abortable = Abortable()\r\n        const fileToJsonOpts = { pms: opts }\r\n\r\n        // FIXME: implement progress properly\r\n        if (args[0] && args[0].progress) {\r\n          fileToJsonOpts.onProgressIncrement = createOnProgressIncrement(args[0].progress)\r\n          delete args[0].progress\r\n        }\r\n\r\n        const readFnName = shortid()\r\n\r\n        // Create the through stream what will connect the client to the\r\n        // server, our source is deferred, until the server responds to tell\r\n        // us the name of the read function we can use to pull added file\r\n        // info from.\r\n        const through = function (read) {\r\n          PMS.sink(readFnName, opts)(read)\r\n          return deferred\r\n        }\r\n\r\n        // Call addPullStream on the server, sending the name of the read\r\n        // function it can use to pull files to add from.\r\n        addPullStream(functionToJson(readFnName), ...args)\r\n          .then((res) => deferred.resolve(PMS.source(res.name, opts)))\r\n          .catch((err) => abortable.abort(err))\r\n\r\n        return pull(\r\n          pull.map((file) => fileToJson(file, fileToJsonOpts)),\r\n          through,\r\n          abortable\r\n        )\r\n      }\r\n    })()\r\n  }\r\n\r\n  return api\r\n}\r\n\r\nfunction createOnProgressIncrement (onProgress) {\r\n  let bytes = 0\r\n  return (incrementBytes) => {\r\n    bytes += incrementBytes\r\n    onProgress(bytes)\r\n    return bytes\r\n  }\r\n}\r\n\r\nfunction fileToJson (file, opts) {\r\n  opts = opts || {}\r\n\r\n  if (isBuffer(file)) { // Buffer\r\n    if (opts.onProgressIncrement) opts.onProgressIncrement(file.length)\r\n    return bufferToJson(file)\r\n  } else if (isStream.readable(file)) { // Node stream\r\n    return pullStreamToJson(toPull.source(file), opts)\r\n  } else if (isSource(file)) { // Pull stream\r\n    return pullStreamToJson(file, opts)\r\n  } else if (file && file.content) { // Object { path?, content }\r\n    return Object.assign({}, file, { content: fileToJson(file.content, opts) })\r\n  }\r\n\r\n  return file // Object { path } maybe, but could be anything\r\n}\r\n\r\nconst pullStreamToJson = (source, opts) => {\r\n  opts = opts || {}\r\n  const readFnName = shortid()\r\n\r\n  pull(\r\n    source,\r\n    PMS.sink(readFnName, Object.assign({}, opts.pms, {\r\n      post (res) {\r\n        if (isBuffer(res.data)) {\r\n          if (opts.onProgressIncrement) opts.onProgressIncrement(res.data.length)\r\n          res.data = bufferToJson(res.data)\r\n        }\r\n\r\n        return res\r\n      }\r\n    }))\r\n  )\r\n\r\n  return functionToJson(readFnName)\r\n}\r\n"]}