{"version":3,"sources":["../../src/server/pubsub.js"],"names":["getIpfs","opts","subs","api","publish","pre","pubsub","subscribe","args","sub","topic","stubFn","Object","assign","data","seqno","name","rpc","fnName","push","catch","err","splice","indexOf","unsubscribe","find","s","peers","ls","close","Promise","all","map","then"],"mappings":"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","file":"pubsub.js","sourcesContent":["import { expose, caller } from 'postmsg-rpc'\r\nimport { pre } from 'prepost'\r\nimport { isFunctionJson } from '../serialization/function'\r\nimport { isBuffer, bufferToJson, preBufferFromJson } from '../serialization/buffer'\r\n\r\nexport default function (getIpfs, opts) {\r\n  const subs = [\r\n  /*\r\n    {\r\n      topic,    // name of the topic subscribed to\r\n      rpc: {    // details of the RPC stub created to send updates\r\n        fnName, // the RPC function name the stub calls\r\n        stubFn  // the RPC stub function created by postmsg-rpc\r\n      }\r\n    }\r\n  */\r\n  ]\r\n\r\n  const api = {\r\n    publish: expose('ipfs.pubsub.publish', pre(\r\n      preBufferFromJson(1),\r\n      opts.pre('pubsub.publish'),\r\n      (...args) => getIpfs().pubsub.publish(...args)\r\n    ), opts),\r\n    subscribe: expose('ipfs.pubsub.subscribe', function (...args) {\r\n      let sub\r\n\r\n      return pre(\r\n        (...args) => {\r\n          const topic = args[0]\r\n\r\n          if (isFunctionJson(args[1])) {\r\n            const stubFn = pre(\r\n              (...args) => {\r\n                if (args[0]) {\r\n                  args[0] = Object.assign({}, args[0])\r\n\r\n                  if (isBuffer(args[0].data)) {\r\n                    args[0].data = bufferToJson(args[0].data)\r\n                  }\r\n\r\n                  if (isBuffer(args[0].seqno)) {\r\n                    args[0].seqno = bufferToJson(args[0].seqno)\r\n                  }\r\n                }\r\n\r\n                return args\r\n              },\r\n              caller(args[1].name, opts)\r\n            )\r\n\r\n            sub = {\r\n              topic,\r\n              rpc: {\r\n                fnName: args[1].name,\r\n                stubFn\r\n              }\r\n            }\r\n\r\n            subs.push(sub)\r\n\r\n            args[1] = stubFn\r\n          }\r\n\r\n          return args\r\n        },\r\n        opts.pre('pubsub.subscribe'),\r\n        (...args) => {\r\n          return getIpfs().pubsub.subscribe(...args)\r\n            .catch((err) => {\r\n              subs.splice(subs.indexOf(sub), 1)\r\n              throw err\r\n            })\r\n        }\r\n      )(...args)\r\n    }, opts),\r\n    unsubscribe: expose('ipfs.pubsub.unsubscribe', pre(\r\n      (...args) => {\r\n        const topic = args[0]\r\n\r\n        if (isFunctionJson(args[1])) {\r\n          const sub = subs.find((s) => s.topic === topic && s.rpc.fnName === args[1].name)\r\n\r\n          if (sub) {\r\n            args[1] = sub.rpc.stubFn\r\n            subs.splice(subs.indexOf(sub), 1)\r\n          } else {\r\n            // Well, we don't have a reference to it, so the ipfs node won't\r\n            // either. We shouldn't error either because ipfs won't.\r\n            args[1] = () => {}\r\n          }\r\n        }\r\n\r\n        return args\r\n      },\r\n      opts.pre('pubsub.unsubscribe'),\r\n      (...args) => getIpfs().pubsub.unsubscribe(...args)\r\n    ), opts),\r\n    peers: expose('ipfs.pubsub.peers', pre(\r\n      opts.pre('pubsub.peers'),\r\n      (...args) => getIpfs().pubsub.peers(...args)\r\n    ), opts),\r\n    ls: expose('ipfs.pubsub.ls', pre(\r\n      opts.pre('pubsub.ls'),\r\n      (...args) => getIpfs().pubsub.ls(...args)\r\n    ), opts)\r\n  }\r\n\r\n  // Clean up any subscriptions on close\r\n  api.subscribe.close = pre(\r\n    (...args) => {\r\n      return Promise.all(\r\n        subs.map((sub) => getIpfs().pubsub.unsubscribe(sub.topic, sub.rpc.stubFn))\r\n      ).then(() => args)\r\n    },\r\n    api.subscribe.close\r\n  )\r\n\r\n  return api\r\n}\r\n"]}